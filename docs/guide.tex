\documentclass[9pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[mono=false]{libertine}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{mathrsfs}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage[colorlinks]{hyperref}
\usepackage{wrapfig}

\usepackage{soul}

\usepackage{todonotes}

\input{macros}

\title{POPACheck User's Guide}
\author{Michele Chiari, Francesco Pontiggia}
\date{}

\begin{document}

\maketitle

\begin{abstract}
POPACheck is an extension of the POMC model checker towards probabilistic recursive programs, modelled as probabilistic Operator Precedence Automata (pOPA). As specification formalisms, it supports Linear Temporal Logic (LTL) and a fragment of Precedence-Oriented Temporal Logic (POTL), a logic for context-free properties such as pre/post-conditioning. Given a pOPA and a formula, it can solve both qualitative and quantitative model check queries. Additionally, it can approximate the termination probability of a pOPA. Computing Termination probabilities are a central problem in probabilistic pushdown model checking, and amounts at solving positive polynomial systems.
This document is a reference guide to its input and output formats, and also describes at a high level its architecture and source code.
\end{abstract}

\section{Introduction}
Precedence-Oriented Temporal Logic~(POTL) \cite{ChiariMP21,ChiariMP21b} is an established temporal
logic formalism based on the family of Operator Precedence Languages~(OPL)~\cite{MP18},
a subclass of deterministic context-free languages.
Given a POTL formula, the POMC tool can translate it into an Operator Precedence BÃ¼chi Automaton~(OPBA), a class of~(nondeterministic, non-probabilistic) Pushdown Automata.

pOPA~\cite{abs-2404-03515} are a class of probabilistic pushdown automata based on OPLs. While they do not read an input, which would make any model checking problem undecidable, the (infinite-length) traces of state labels collected in the paths of a given pOPA constitute an OPL. POPACheck exploits the fact that OPL are closed by Boolean operations (including intersection, complementation \dots). Roughly speaking, POPACheck takes as input a formula and a program in a custom DSL called MiniProb, it translates the program into a pOPA, it uses POMC modules to translate the formula into an OPBA, and finally verifies the pOPA against the OPBA via automata-based model checking, i.e., via a cross-product. Involved technicalities arise due to the fact that the pOPA is equipped with an unbounded stack, and that we do not perform determinization of the specification OPBA. We'll skip them here. We just mention that the pOPA can be represented by a finite-state Markov Chain called \emph{support chain}. The support chain can be computed by solving (nonlinear) positive polynomial systems of equations. Solutions to these systems are called \emph{termination probabilities}. Due to their nonlinearity, they cannot be solved exactly. Our tool computed sound lower and upper bounds to termination probabilities. While it computes lower bound always via numerical methods, it offers two approaches for upper bounds: one is purely numerical, and it is called OVI; the other one relies on the SMT solver Z3.

Similar equation systems arise in quantitative model checking - we call them \emph{fractions} due to technical reasons reported in \cite{POPACheck}. Similarly POPACheck compute lower and upper bounds to the solutions of these systems (in this case always via OVI). This means that when running quantitative model checking POPACheck will return a lower and an upper bound to the satisfaction probability.

We show how to use POPACheck in Section~\ref{sec:quick-start}.
If you wish to examine the input formulas and OPA for the experiments more carefully,
or to write your own, we describe the format of POMC input files in Sections~\ref{sec:format},~\ref{sec:queries}, and~\ref{sec:output}.
Finally, Section~\ref{sec:sources} contains a high-level description of the source code.

\section{Quick-Start Guide}
\label{sec:quick-start}

POPACheck, just like POMC, has been developed in the Haskell programming language,
and packaged with the Haskell Tool Stack\footnote{\url{https://www.haskellstack.org/}}.
POPACheck has a few dependencies:
\begin{itemize}
    \item \href{https://microsoft.github.io/z3guide/z3}{Z3} for solving (nonlinear) equations systems.
    \item \href{https://www.netlib.org/lapack/}{BLAS/LAPACK} for approximating solutions to equation systems via iterative fixpoint numerical methods (the Newton method).
\end{itemize}
On a UNIX-like system, they can be resolved by running:
\begin{verbatim}
sudo apt install libz3-dev libgsl0-dev liblapack-dev libatlas-base-dev
\end{verbatim}

The Z3 library requires special care, as it might conflict with the underlying OS. The current version of the tool (14.04.2025) has been fully tested with Z3 version 4.8.12 and Ubuntu 24. Note that version 4.8.12 is the one installed by default by the APT package index on Ubuntu 24. On the other side, we experienced some issues on Ubuntu 22, where Z3 sometimes returns error \verb|Z3: invalid argument|. Please report to the POPACheck team in case you experience some issue.

After having resolved the dependencies, POPACheck can be built from sources by typing the following commands in a shell:
\begin{verbatim}
$ cd ~/path/to/POPACheck-sources
$ stack setup
$ stack build
\end{verbatim}
Then, POPACheck can be executed on an input file \verb|file.pomc| as follows:
\begin{verbatim}
$ stack exec popacheck -- file.pomc {args}
\end{verbatim}

POPACheck stack commands take a few interesting arguments:
\begin{itemize}
    \item \verb|--noovi| [default: False]. When set, POPACheck uses Z3 instead of OVI for computing upper bounds to termination probabilities. As the experimental evaluation of \cite{POPACheck} suggests, this leads almost always to timeouts.
    \item \verb|--newton| [default: False]. When set, POPACheck uses the Newton method for computing lower bounds to termination probabilities, and to fractions in quantitative model checking. We refer to PreMo \cite{WojtczakE07,Wojtczak09} for a detailed description of these two numerical methods. In our experiments, the Newton method tends to be slightly faster than Gauss-Seidel, hence we encourage users to set this flag.
    \item $\texttt{-verbose}$ [default: 0]. Logging level. 0 = no logging, 1 = show info, 2 = debug mode.
\end{itemize}

Directory \verb|eval| contains the Python script \verb|probbench.py|,
which may be useful to evaluate POPACheck input files, as it also prints
a summary of the resources used by POPACheck.
It must be executed with a subdirectory of \verb|~/path/to/POPACheck-sources| as its working directory, and either \verb|--print| to print the results in the shell, or \verb|--raw_csv file_name| for saving the results in csv format in \verb|file_name|.

\begin{verbatim}
$ cd ~/path/to/POPACheck-sources/eval
$ ./probbench.py prob/established/qualitative --print
\end{verbatim}
evaluates all \verb|*.pomc| files in directory \\ \verb|~/path/to/POPACheck-sources/eval/prob/established/qualitative|.


\begin{figure}
\begin{align*}
\mathit{prog} \coloneqq & \; [\mathit{decl} ; \dots] \; \mathit{func} \; [\mathit{func} \dots] \\
\mathit{decl} \coloneqq & \; \mathit{type \; identifier} \; [, \mathit{identifier} \dots] \\
\mathit{type} \coloneqq & \; \mathtt{bool} \mid \mathtt{u}\mathit{int} \mid \mathtt{s}\mathit{int} \mid \mathtt{u}\mathit{int}[\mathit{int}] \mid \mathtt{s}\mathit{int}[\mathit{int}] \\
\mathit{func} \coloneqq & \; f \texttt{(}\mathit{type} \; [\&] x_1 \; [, \mathit{type} \; [\&] x_2 \dots]\texttt{)} \\
  &\; \{ [\mathit{decl} ; \dots] \; \mathit{block} \} \\
\mathit{stmt} \coloneqq
    & \; \mathit{lval} = e \\
    &\mid \mathit{lval} = \mathtt{Distribution}\texttt{(} \dots \texttt{)} \\
    &\mid \mathit{lval} = e_1 \{ e_2 : e_3 \} [e_4 \{ e_5 : e_6 \} \dots] e_n \\
%    &\mid f\texttt{(}e_1 \mid \mathit{lval}_1 \; [, e_2 \mid \mathit{lval}_2 \dots]\texttt{)} \\
    &\mid [\texttt{query}] \; f\texttt{(}e_1 \mid \mathit{lval}_1 \; [, e_2 \mid \mathit{lval}_2 \dots]\texttt{)} \\
    &\mid \mathtt{if} \; \texttt{(}e\texttt{)} \; \{ \mathit{block} \} \ \mathtt{else} \ \{ \mathit{block} \} \\
    &\mid \mathtt{while} \; \texttt{(}e\texttt{)} \; \{ \mathit{block} \} \\
    &\mid \mathtt{observe} \; \texttt{(}e\texttt{)} \\
\mathit{block} \coloneqq & \; \mathit{stmt} ; [\mathit{stmt} \dots ; ] \\
\mathit{lval} \coloneqq & \; \mathit{identifier} \mid \mathit{identifier}[e]
\end{align*}
\caption{MiniProb syntax.}
\label{fig:miniprob}
\end{figure}

\section{Input Language}
\label{sec:format}

POPACheck analyzes programs written in MiniProb, a simple probabilistic programming language (Fig.~\ref{fig:miniprob}). MiniProb programs are written in files with extension \verb|.pomc|.
MiniProb supports (un)signed integer variables of arbitrary width
(\texttt{u8} is an 8-bit unsigned type) and fixed-size arrays.
Functions take parameters by value or value-result (with \&).
Actual parameters can only be variable identifiers for value-result parameters,
and any expression if passed by value.
Expressions consist of variables, array indexing, integer constants, and the usual arithmetic and Boolean operators, including comparisons.
Boolean operators handle integers (0 means false, everything else true).
Programs may sample from $\texttt{Bernoulli(} e_1, e_2 \texttt{)}$,
% what about "where p = e1 / e2" magari killiamo la vedova
which returns 1 with probability $p = e_1 / e_2$, and 0 with probability $1-p$,
or from $\texttt{Uniform(} e_1, e_2 \texttt{)}$,
which samples uniformly among integers from $e_1$ to $e_2 - 1$.
Random assignments of the form $x = e_1 \{ e_2 / e_3 \} e_4$ mean that $x$ is assigned
the value of $e_1$ with probability $e_2 / e_3$, and $e_4$ with probability $1 - e_2 / e_3$.
Finally, functions can \texttt{query} the distribution on value-result parameters of another function, and condition on a Boolean expression with \texttt{observe}.

\section{Queries}
\label{sec:queries}
A model check query must be put at the beginning of a \verb|.pomc| file, before the program. It follows the syntax: 
\begin{center}
    $\texttt{probabilistic query:} \, \, q \texttt{;}$
\end{center}
where $q$ is one of the queries of Table \ref{tab:queries}. When a formula is needed, it has to be placed in a new line with syntax:
\begin{center}
    $\texttt{formula:} \, \, f \texttt{;}$
\end{center}
where $f$ follows the syntax of Table \ref{tab:potl-syntax}. For some technical reasons explained in \cite{abs-2404-03515}, POPACheck does not support the whole POTL logic. In a nutshell, this is due to the fact that the model check algorithm avoids determinization of the specification automata. We do support full LTL though. To get a idea of queries, consider inspecting different experiments in \verb|eval/prob/established/|, where the same programs are verified against different queries.

Plain reachability queries are supported through the LTL $\texttt{Eventually}$ operator at the moment. We plan to optimize it in future work, as it could be encoded as a termination query. 

POPACheck supports also the query $\texttt{unfold\&export}$, which constructs a Markov Chain in explicit \href{https://www.stormchecker.org/documentation/background/languages.html}{Storm} format for a given program by unfolding the program's stack. Argument \verb|maxDepth| to the stack command specifies the maximum stack depth to unfold [default: 100]. When \verb|maxDepth| is reached, recursion is not unfolded anymore, and a simple self-loop is added. Note that \verb|.pomc| programs may have infinite recursion. We use this feature for testing purposes, and do not advertise users to try it out.

\begin{table}
\centering
\begin{tabular}{| l | l | l |}
\hline
 query & explanation & Formula? \\
\hline
\hline
$\texttt{approximate}$ & what is the termination probability of the program? & No \\ 
$\texttt{qualitative}$ & Does the program satisfy $f$ almost surely? & Yes \\ 
$\texttt{quantitative}$ & What is the probability that the program satisfies $f$? & Yes \\ 


\hline
\end{tabular}
\caption{Available queries.}
\label{tab:queries}
\end{table}

\begin{table}
\centering
\begin{tabular}{| c | l | l | l | l |}
\hline
Group & POTL (or LTL) Operator & POPACheck Operator & Notation & Associativity \\
\hline
\hline
\multirow{15}{*}{\rotatebox[origin=c]{90}{Unary}}
& $\neg$ & \verb!~!, \texttt{Not} & Prefix & -- \\
& $\ldnext$ & \texttt{PNd}           & Prefix & -- \\
& $\lunext$ & \texttt{PNu}           & Prefix & -- \\
& $\ldback$ & \texttt{PBd}           & Prefix & -- \\
& $\luback$ & \texttt{PBu}           & Prefix & -- \\
& $\lcdnext$ & \texttt{XNd}           & Prefix & -- \\
& $\lcunext$ & \texttt{XNu}           & Prefix & -- \\
& \st{$\lcdback$} & \st{\texttt{XBd}}           & \st{Prefix} & -- \\
& \st{$\lcuback$} & \st{\texttt{XBu}}           & \st{Prefix} & -- \\
& \st{$\lhdnext$} & \st{\texttt{HNd}}           & \st{Prefix} & -- \\
& \st{$\lhunext$} & \st{\texttt{HNu}}          & \st{Prefix} & -- \\
& \st{$\lhdback$} & \st{\texttt{HBd}}          & \st{Prefix} & -- \\
& \st{$\lhuback$} & \st{\texttt{HBu}}          & \st{Prefix} & -- \\
& $\lleven \,$ (LTL)& \texttt{F}, \texttt{Eventually}  & Prefix & -- \\
& $\lnext \,$ (LTL)& \texttt{N} & Prefix & -- \\
& $\mathcal{U} \,$ (LTL)& \texttt{U} & Infix & Right \\
& $\llglob \, $ (LTL)& \texttt{G}, \texttt{Always} & Prefix & -- \\
\hline
\multirow{8}{*}{\rotatebox[origin=c]{90}{POTL Binary}}
& $\lcduntil{}{}$ & \texttt{Ud}            & Infix  & Right \\
& $\lcuuntil{}{}$ & \texttt{Uu}            & Infix  & Right \\
& \st{$\lcdsince{}{}$} & \st{\texttt{Sd}}            & \st{Infix}  & \st{Right} \\
& \st{$\lcusince{}{}$} & \st{\texttt{Su}}            & \st{Infix}  & \st{Right} \\
& \st{$\lhduntil{}{}$} & \st{\texttt{HUd}}           & \st{Infix}  & \st{Right} \\
& \st{$\lhuuntil{}{}$} & \st{\texttt{HUu}}           & \st{Infix}  & \st{Right} \\
& \st{$\lhdsince{}{}$} & \st{\texttt{HSd}}           & \st{Infix}  & \st{Right} \\
& \st{$\lhusince{}{}$} & \st{\texttt{HSu}}           & \st{Infix}  & \st{Right} \\
\hline
\multirow{5}{*}{\rotatebox[origin=c]{90}{Prop.\ Binary}}
& $\land$ & \texttt{And}, \verb!&&! & Infix  & Left \\
& $\lor$ & \texttt{Or}, \verb!||!  & Infix  & Left \\
& $\oplus$ & \texttt{Xor}           & Infix  & Left \\
& $\implies$ & \texttt{Implies}, \verb!-->!  & Infix  & Right \\
& $\iff$ & \texttt{Iff}, \verb!<-->!     & Infix  & Right \\
\hline
\end{tabular}
\caption{This table contains all POTL and LTL operators, in descending order
of precedence. Operators listed on the same line are synonyms. Operators in the
same group have the same precedence. Note that operators are case sensitive. \textbf{Operators not in the fragment supported by POPACheck are crossed out.}}
\label{tab:potl-syntax}
\end{table}

\clearpage
\section{Interpreting the output}
The output of running a query is quite verbose at the moment. For example: 
\begin{verbatim}
$ stack exec -- popacheck prob/established/quantitative/schelling/Q03.pomc --newton
\end{verbatim}
prints 
\begin{verbatim}
Quantitative Probabilistic Model Checking
Query: G (((call And alice) And [| (p == [4]4)]) --> (~ (XNu obs)))
Result:  (5064173399 % 5660011320,6145 % 6868)
Floating Point Result:  (0.8947284930518479,0.894729178800233)
Elapsed time: 20.74 s (total), 2.3883e-2 s (upper bounds), 2.8956e-2 s (PAST certificates), 1.1778e0 s (graph analysis),1.1905e1 s (upper bounds with OVI for quant MC),7.5453e-4 s (eq system for quant MC).
Input pOPA state count: 311
Support graph size: 682
Equations solved for termination probabilities: 1230
Non-trivial equations solved for termination probabilities: 266
SCC count in the support graph: 1117
Size of the largest SCC in the support graph: 24
Largest number of non trivial equations in an SCC in the Support Graph: 52
Size of graph G: 44
Equations solved for quant mc: 893036
Non-trivial equations solved for quant mc: 68226
SCC count in quant mc weight computation: 336410
Size of the largest SCC in quant mc weight computation: 144
Largest number of non trivial equations in an SCC in quant mc weight computation: 7318

\end{verbatim}
Most of lines just print statistics about the experiment. An user may only read
\begin{verbatim}
Floating Point Result:  (0.8947284930518479,0.894729178800233)
\end{verbatim}
which are, respectively, a lower and an upper bound to the probability that the schelling model satisfies formula Q03. It might be of general interest to inspect the overall number of equation solved, 893036 in this case.

\section{Source Code}
\label{sec:sources}

POPACheck is open source. The source code of POPACheck is contained in directory \texttt{src/Pomc/Prob}. We refer to the documentation of POMC for the other modules.
We describe the contents of each file below.
\begin{description}
\item[FixPoint.hs] contains the data structures to represent and store sparse systems of positive polynomial systems, and vectors of solutions (termination probabilities). Given a system, it keeps track of those equations that are not solved, and allows to approximating their solutions via either the Gauss-Seidel method or the Newton method.
\item[GGraph.hs]  contains the implementation of qualitative and quantitative model checking. It also contains some functions for building the cross-product between the formula's automaton and the support chain of the pOPA (what is called graph $G$ in \cite{abs-2404-03515}).
\item[GReach.hs] contains functions for exploring edges in graph $G$ that correspond to support edges in the summary chain of the pOPA. For qualitative model checking, it has a simple reachability algorithm for building these edges. For quantitative model checking, it has a SCC-based algorithm for computing (bounds to) the fraction associated with each edge via OVI. This amounts at solving positive polynomial systems in the same vein as termination probabilities.
\item[MiniProb.hs] This file contains the parser and the implementation of the MiniProc programming language.
\item[OVI.hs] contains our implementation of Optimistic Value Iteration (OVI) for computing upper bounds to the solution of positive polynomial systems.
\item[ProbEncoding.hs] contains functions for generating a encoding of formulae satisfied in a path via bitvectors.
\item[ProbModelChecking.hs] exposes all our probabilistic model checking APIs.
\item[ProbUtils.hs] contains various utility functions.
\item[SupportGraph.hs] contains a function for building the support graph of an input pOPA, an intermediate formalism for the computation of the support chain. 
\item[Z3Termination.hs] contains the function for computing termination probabilities of a pOPA, either via OVI or via Z3, and certifying via Z3 that such probabilities are exactly equal to one when needed, according to the semialgorithm of \cite{POPACheck}. 

\end{description}

\subsection{Test Suite}
The \texttt{test} directory contains regression tests based on the HUnit
provider of the Tasty\footnote{\url{https://github.com/UnkindPartition/tasty}} framework.
They can be run with
\begin{verbatim}
$ stack test
\end{verbatim}
but note that some of them may take a very long time or exhaust your memory.
To learn how to execute just some of them, please consult the \texttt{README.md}
file in the \texttt{test} directory.

\section*{Acknowledgements}
We are thankful to Tobias Winkler and Joost-Pieter Katoen (RWTH Aachen)
for the fruitful discussions and for the advice on implementing OVI.

\bibliographystyle{abbrv}
\bibliography{pomc}

\appendix



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
