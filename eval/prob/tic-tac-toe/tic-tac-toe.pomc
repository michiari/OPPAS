probabilistic query: quantitative;
formula = F (G ([|final_winner == 0u2]));

program:
u2[3] upper;
u2[3] middle;
u2[3] lower;
u2 final_winner;

/*  
    0 = non assigned
    1 = circle (player 0)
    2 = cross (player 1)
    Initial Condition: 
    |   | O |   |
    | O | X | X |
    |   | O |   |
Reference: A. Stuhlmueller, N.D. Goodman, Reasoning about Reasoning by Nested Conditioning: Modeling Theory of Mind with Probabilistic Programs, Cognitive Systems Research 2014.
*/ 

main (){
    upper[0u2] = 0u2;
	upper[1u2] = 1u2;
	upper[2u2] = 0u2;
    middle[0u2] = 1u2;
	middle[1u2] = 2u2;
	middle[2u2] = 2u2;
    lower[0u2] = 0u2;
	lower[1u2] = 1u2;
	lower[2u2] = 0u2;

    query sample_action(2u2);
}

sample_action(u2 current_player) {
    bool another_turn;
    u2 other_player;

    // sample a choice from the priori
    query action_priori(current_player);
    
    // is the grid now filled?
    another_turn = upper[0u2] == 0u2 || upper[1u2] == 0u2 || upper[2u2] == 0u2 || middle[0u2] == 0u2 || middle[1u2] == 0u2 || middle[2u2] == 0u2 || lower[0u2] == 0u2 || lower[1u2] == 0u2 || lower[2u2] == 0u2;

    if (another_turn) {    
        // passing the turn
        if (current_player == 1u2) {
            other_player = 2u2;
        } else {
        other_player = 1u2;
        }
        query sample_action(other_player);

    } else {}

    // computing the expected utility
    expected_utility(current_player);
}


action_priori(u2 current_player) {
    u2 row_choice, column_choice;
    row_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2;
    column_choice = 0u2 {1u2 : 3u2} 1u2 {1u2: 3u2} 2u2;
    // observe that the choice is feasible, and update the grid
    if (row_choice == 0u2) {
        observe upper[column_choice] == 0u2;
        upper[column_choice] = current_player;
    } else {
        if (row_choice == 1u2) {
            observe middle[column_choice] == 0u2;
            middle[column_choice] = current_player;
        } else {
            observe lower[column_choice] == 0u2;
            lower[column_choice] = current_player;
        }
    }
}

// this procedure is technically wrong, but working on this practical case of tic-tac-toe (a tris of non assigned cells will elect 0 as a winner)
winning_condition(u2 &winner) {
    if (upper[0u2] == upper[1u2] && upper[1u2] == upper[2u2]) {
        winner = upper[0u2];
    } else {
        if (middle[0u2] == middle[1u2] && middle[1u2] == middle[2u2]) {
            winner = middle[0u2];
        } else {
            if (lower[0u2] == lower[1u2] && lower[1u2] == lower[2u2]) {
                winner = lower[0u2];
            } else {
                if (upper[0u2] == middle[0u2] && middle[0u2] == lower[0u2]) {
                    winner = upper[0u2];
                } else {
                    if (upper[1u2] == middle[1u2] && middle[1u2] == lower[1u2]) {
                        winner = upper[1u2];
                    } else {
                        if (upper[2u2] == middle[2u2] && middle[2u2] == lower[2u2]) {
                            winner = upper[2u2];
                        } else {
                            if (upper[0u2] == middle[1u2] && middle[1u2] == lower[2u2]) {
                                winner = upper[0u2];
                            } else {
                                if (upper[2u2] == middle[1u2] && middle[1u2] == lower[0u2]) {
                                    winner = upper[2u2];
                                } else {
                                    winner = 0u2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

expected_utility(u2 current_player) {
    bool coin_flip;
    u2 winner;
    u4 utility;

    winning_condition(winner);
    final_winner = winner;
    if (winner == current_player) {
        utility = 10u4;
    } else {
        if (winner == 0u2) {
        utility = 5u4;
        } else {
            utility = 1u4;
        }
    }

    // outcome should range from 0 to 10
    coin_flip = 1u1 {utility : 10u4} 0u1;
    observe coin_flip;
}

// helpers
